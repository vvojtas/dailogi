# Avatar Migration Plan

## Overview
This document outlines the plan to migrate the avatar data from being directly stored in the `Character` entity to a separate `Avatar` entity with a one-to-one relationship.

## Motivation
Separating the avatar into its own entity will:
- Improve data organization and domain modeling
- Allow for better query performance by not loading binary data unnecessarily
- Enable more detailed avatar metadata management
- Follow best practices for handling binary large objects (BLOBs)

## Implementation Steps

### 1. Create Avatar Entity

Create a new `Avatar` entity class:

```java
package com.github.vvojtas.dailogi_server.db.entity;

import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.experimental.Accessors;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import jakarta.persistence.*;
import java.time.OffsetDateTime;

@Entity
@Table(name = "Avatar")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Accessors(chain = true)
public class Avatar {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Lob
    @Column(nullable = false)
    private byte[] data;

    @Column(nullable = false, length = 20)
    private String formatType = "image/png"; // Default format, can also be "image/jpeg"

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, columnDefinition = "TIMESTAMP WITH TIME ZONE")
    private OffsetDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false, columnDefinition = "TIMESTAMP WITH TIME ZONE")
    private OffsetDateTime updatedAt;
}
```

### 2. Update Character Entity

Modify the `Character` entity to reference the `Avatar` entity with avatarId field:

```java
// In Character.java
// Remove existing avatar field:
// @Lob
// @Column
// private byte[] avatar;

// Add this field instead:
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "avatar_id", foreignKey = @ForeignKey(name = "fk_character_avatar"))
private Avatar avatar;

// Add avatarId field for faster checks without loading the avatar entity
@Column(name = "avatar_id", insertable = false, updatable = false)
private Long avatarId;
```

Also update appropriate builder and accessor methods.

### 3. Update Database Schema Plan

Update `.ai/db-plan.md` to reflect the new table structure:

```markdown
### c. Tabela `Character`
- **id**: BIGINT, PRIMARY KEY  
- **user_id**: BIGINT NOT NULL  
  - FOREIGN KEY REFERENCES `User`(id) ON DELETE CASCADE  
- **name**: VARCHAR(100) NOT NULL  
  - Unikalność w obrębie użytkownika: UNIQUE(user_id, name)  
- **description**: TEXT NOT NULL  
- **short_description**: TEXT NOT NULL  
- **is_global**: BOOLEAN NOT NULL DEFAULT FALSE  
- **default_llm_id**: BIGINT  
  - FOREIGN KEY REFERENCES `LLM`(id) ON DELETE SET NULL  
- **avatar_id**: BIGINT  
  - FOREIGN KEY REFERENCES `Avatar`(id) ON DELETE CASCADE  
- **created_at**: TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP  
- **updated_at**: TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP  

### g. Tabela `Avatar`
- **id**: BIGINT, PRIMARY KEY  
- **data**: BYTEA NOT NULL  
  - Przechowywane jako BLOB; kolumna nie jest indeksowana  
- **format_type**: VARCHAR(20) NOT NULL DEFAULT 'image/png'  
- **created_at**: TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP  
- **updated_at**: TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP  
```

Also update the relations section to reflect this change.

### 4. Update Initial Database Schema

Update `V1__Initial_schema.sql` to reflect the new structure (since we're dropping and recreating the database):

```sql
-- Note: Using BYTEA for avatar data, suitable for PostgreSQL.
create table avatar (id bigint generated by default as identity, created_at TIMESTAMP WITH TIME ZONE not null, data BYTEA not null, format_type varchar(20) not null, updated_at TIMESTAMP WITH TIME ZONE not null, primary key (id));

create table app_user (id bigint generated by default as identity, created_at TIMESTAMP WITH TIME ZONE not null, name varchar(50) not null, is_special_user boolean not null, password_hash TEXT not null, updated_at TIMESTAMP WITH TIME ZONE not null, primary key (id));

create table character (id bigint generated by default as identity, created_at TIMESTAMP WITH TIME ZONE not null, description TEXT not null, is_global boolean not null, name varchar(100) not null, short_description TEXT not null, updated_at TIMESTAMP WITH TIME ZONE not null, avatar_id bigint, default_llm_id bigint, user_id bigint not null, primary key (id));

create table dialogue (id bigint generated by default as identity, created_at TIMESTAMP WITH TIME ZONE not null, name varchar(255) not null, scene_description TEXT, status enum ('COMPLETED','FAILED') not null, updated_at TIMESTAMP WITH TIME ZONE not null, user_id bigint not null, primary key (id));

create table dialogue_character_config (character_id bigint not null, dialogue_id bigint not null, llm_id bigint not null, primary key (character_id, dialogue_id));

create table dialogue_message (id bigint generated by default as identity, content TEXT not null, turn_number integer not null, character_id bigint not null, dialogue_id bigint not null, primary key (id));

create table llm (id bigint generated by default as identity, name varchar(100) not null, openrouter_identifier varchar(100) not null, primary key (id));

alter table if exists app_user drop constraint if exists app_user_name_unique;
alter table if exists app_user add constraint app_user_name_unique unique (name);
alter table if exists character add constraint character_user_name_unique unique (user_id, name);
alter table if exists character add constraint character_default_llm_fk foreign key (default_llm_id) references llm on delete set null;
alter table if exists character add constraint character_avatar_fk foreign key (avatar_id) references avatar on delete cascade;
alter table if exists character add constraint character_app_user_fk foreign key (user_id) references app_user on delete cascade;
alter table if exists dialogue add constraint dialogue_app_user_fk foreign key (user_id) references app_user on delete cascade;
alter table if exists dialogue_character_config add constraint dialogue_character_config_character_fk foreign key (character_id) references character;
alter table if exists dialogue_character_config add constraint dialogue_character_config_dialogue_fk foreign key (dialogue_id) references dialogue;
alter table if exists dialogue_character_config add constraint dialogue_character_config_llm_fk foreign key (llm_id) references llm;
alter table if exists dialogue_message add constraint dialogue_message_character_fk foreign key (character_id) references character;
alter table if exists dialogue_message add constraint dialogue_message_dialogue_fk foreign key (dialogue_id) references dialogue;
```

### 5. Update Character Service

Update the `CharacterService` to handle avatar operations:

1. Update the method that checks if a character has an avatar (use avatarId field)
2. Update the method for uploading an avatar
3. Modify any methods that use the avatar field

### 6. Create Avatar Controller

Create a new controller to serve avatar images:

```java
package com.github.vvojtas.dailogi_server.controller;

import com.github.vvojtas.dailogi_server.service.AvatarService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@Tag(name = "Avatars", description = "Endpoints for accessing character avatars")
public class AvatarController {

    private final AvatarService avatarService;

    @Operation(
        summary = "Get character avatar",
        description = "Retrieves the avatar image for a specific character. Authentication is optional; unauthenticated users can access avatars for global characters."
    )
    @ApiResponses({
        @ApiResponse(
            responseCode = "200",
            description = "Avatar retrieved successfully",
            content = @Content(mediaType = "image/png")
        ),
        @ApiResponse(
            responseCode = "403",
            description = "Forbidden - character is not global and user is not authenticated or does not own the character"
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Character not found or character has no avatar"
        )
    })
    @GetMapping(value = "/api/characters/{characterId}/avatar")
    public ResponseEntity<byte[]> getAvatar(
        @Parameter(
            description = "ID of the character whose avatar to retrieve",
            example = "1"
        )
        @PathVariable Long characterId,
        Authentication authentication
    ) {
        AvatarService.AvatarData avatarData = avatarService.getAvatarData(characterId, authentication);
        if (avatarData == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity
            .ok()
            .contentType(MediaType.parseMediaType(avatarData.getFormatType()))
            .body(avatarData.getData());
    }
}
```

### 7. Implement Avatar Service

Create a new service to handle avatar-related operations:

```java
package com.github.vvojtas.dailogi_server.service;

import com.github.vvojtas.dailogi_server.db.entity.Avatar;
import com.github.vvojtas.dailogi_server.db.entity.Character;
import com.github.vvojtas.dailogi_server.db.repository.AvatarRepository;
import com.github.vvojtas.dailogi_server.db.repository.CharacterRepository;
import com.github.vvojtas.dailogi_server.exception.EntityNotFoundException;
import com.github.vvojtas.dailogi_server.exception.ForbiddenException;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class AvatarService {

    private final AvatarRepository avatarRepository;
    private final CharacterRepository characterRepository;
    private final SecurityService securityService;
    
    @Value
    public static class AvatarData {
        byte[] data;
        String formatType;
    }

    @Transactional(readOnly = true)
    public AvatarData getAvatarData(Long characterId, Authentication authentication) {
        Character character = characterRepository.findById(characterId)
            .orElseThrow(() -> new EntityNotFoundException("Character not found"));
            
        // Allow access if character is global
        if (!character.getIsGlobal()) {
            // If not global, verify the user owns this character
            securityService.validateCharacterOwner(character, authentication);
        }
        
        // Check if character has an avatar using the avatarId field
        if (character.getAvatarId() == null) {
            return null;
        }
            
        return avatarRepository.findById(character.getAvatarId())
            .map(avatar -> new AvatarData(avatar.getData(), avatar.getFormatType()))
            .orElse(null);
    }
}
```

### 8. Create Avatar Repository

Create a repository interface for Avatar entities:

```java
package com.github.vvojtas.dailogi_server.db.repository;

import com.github.vvojtas.dailogi_server.db.entity.Avatar;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface AvatarRepository extends JpaRepository<Avatar, Long> {
}
```

### 9. Update CharacterMapper

Update the mapper to handle the new relationship:

```java
// In CharacterMapper

// When converting Character to DTO
public CharacterDTO toDTO(Character character) {
    boolean hasAvatar = character.getAvatarId() != null;
    String avatarUrl = hasAvatar ? "/api/characters/" + character.getId() + "/avatar" : null;
    
    return new CharacterDTO(
        character.getId(),
        character.getName(),
        character.getShortDescription(),
        character.getDescription(),
        hasAvatar, // has_avatar remains the same logic
        avatarUrl, // avatar_url points to the endpoint
        character.getIsGlobal(),
        character.getDefaultLlm() != null ? character.getDefaultLlm().getId() : null,
        character.getCreatedAt(),
        character.getUpdatedAt()
    );
}
```

## Rollback Plan

In case of issues:

1. Revert code changes
2. Restore the original V1__Initial_schema.sql file
3. Recreate the database with the original schema

## Timeline Estimate

- Schema design and entity creation: 1 day
- Migration script implementation: 1 day
- Service and controller implementation: 2 days
- Testing and validation: 2 days
- Documentation and code review: 1 day

Total: 7 days 